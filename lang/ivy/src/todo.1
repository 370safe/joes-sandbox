Things I'm not so sure about:

	2. we now allow fn a.b.c() { }
		The problem is that we're calling the generic code generator
for the left side of ().  So something like fn 10() { } is valid syntax (but
will say invalid l-value at run time).  Hmm.. this might all be ok.


Nifty features:

	LAND and LOR as in Lua

	Spread to convert array to argument list

	Pipeline function calls as in javascript: |>

	Arrow functions: arg => expr

	How to determine if object is missing an item, vs. it being there
	but with void value?

	NaN and Infinity values

	** for exponentiation or overload ^?

	printf as in Python

	advancing scan

Loading:

->	Add Lua like loadstring and loadfile... make module system out of
	this.

	Dump non-working include statement

	Need module path I think...

	It would be nice if you could assign this.  Then you could
	include all exports with this|=loadfile("lib.i")

Debug:

->	Print line number or better line when there are errors

->	Also print stack trace with function name and line references

C interface:

	Make it as easy as possible

	Store C data and pointers, like FILEs

Thunks:

->	Add a way to explicitly set the environment during a function
	call:

		z = &x++
		test = [`x=3]
		z(`mom=test)	# <- works, but what about for '*' syntax?

	For thunks, should it be setting 'this'?  They are not supposed
	to have their own scope.

	But 'this' is magic...

i18n:

->	Allow UTF-8 symbols

->	UTF-8 strings and character constants.  Utilities for bytes and
	characters.

->	Incorporate regex from JOE

Tests:

->	continue

Performance:

	Only extra arguments should go into argv [done]

	We create scope level and argv when we index objects and strings..
	this is way too much overhead.

	We create a scope level for if body.. this is slow.. should
	we have no scope levels?
	It's slow because of increase mom access.  Make mom faster..
	
	Make switch native?

	Garbage collector:

		use an allocator for the protection structures

		can we eliminate the protection structures?  Mark newly created objects
		some other way (generation number in the object or something)

New features:
	Exceptions.

	Continuations or co-routines (haven't decided yet: leaning towards
	co-routines, but designing for continuations).

	First-class regular expressions, as in perl.

	All UNIX system calls and library functions, as in perl.

	Widget library and X interface.  I'd like to use Ivy as a
	replacement for "gnu-plot" (and when built into JOE, as a free
	version of "mathcad").

	Iterators, and/or common interface for foreach and forindex

	List comprehensions

Safety

	ivy_globals should be read-only I think.  This way loaded files
	always see the same thing.

	popall doesn't free callstates..
