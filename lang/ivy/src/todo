
Notes from other languages:

Lua:
	x == (a || b)
		x set to a if it's true, b otherwise

	x == (a && b)
		x set to a if it's false, b otherwise

	foo = require "mymodule"
	foo.bar()     ...Call method bar from foo

	It calls mymodule file as a function.  This must return a table which becomes foo above.  "require" remembers if a module was already loaded.

		local mymodule = {}
		function mymodule.bar()
			print "foo"
		end
		return mymodule

	mymodule is not a scope: you can't mymodule.print from it... so only the module's items are included in it.

	In Lua you can add modules to tables using '.':
		function fred.x()...
		(same as js fred.x = function...)

	x is added to fred..

	Calling member functions looks like this:

		a:fred(10)     ':' means first argument will be a, as in:
		a.fred(a, 10)

	Also 'self' will be added in definitions:

		function Example:fred(x) same as

		function Example.fred(self,x)

	Inheritance:

	First create a prototype:

		Account = { balance = 0 }	# Prototype for Account

		Account:new(o)	# Self will be Account here- it's called Account:new()
			o = o or {}
			#o.balance = 0		<- instance variable
			# above is not needed.. on read it will use balance from the prototype..
			setmetatable(o, self)   <- Objects have a metatable...
			self.__index = self	<- The __index is where it does scope-like lookup
			return o

		Account:deposit(n)		# Self will be o here.  o:deposit(10)
			self.balance += n

		SpecialAccount = Account:new()	# Create a derived type prototype here (no different from create instance)
			# SpecialAccount's metatable will be Account

		i = SpecialAccount:new{limit=100}	# New gets SpecialAccount here..
							# i's metatable will be SpecialAccount..

	It has syntax for passing a single argument table to a function: foo{x=0,y=0,z=0}
	(it otherwise has no named argument call)

	It has syntax for variable number of arguments foo(...) -> they end up in a table called arg

	It has very nice iterators:
		Create a function f that returns a function to call to retreive the next item.
		Use generic for to use it: for i in f(t) do ... end

	It has f = loadstring("i = i + 1") or f = loadfile(filename)
	F is function that executes the compiled code.  Modules are built on top of this for sure.

	It has coroutines.

Python:

	Classes:

		class foo(BaseClass):
			x=10
			def __init__(self, iz):  # Magic special init function
				BaseClass.__init__(self)
				self.x=iz
			def myfunc(self):
				print self.x

		instance = foo(10)  # create instance, __init__ is called.

	class.member   self not automatically inserted
        instance.member   self is automatically inserted

	Magic methods:
		__str__    How it's printed

	Modules:

		import module
		import module as foo
		from module import name

	Iterators:
		it = iter(foo)   Gets iterator of class (calls __iter__())
		next(it)         Get next value
		for x in foo:    Nice syntax for this.
		raise StopIteration to indicate end..

	_ can be used to ignore in multiple assign x, _, z = 1, 2, 3;
	names beginning with _ are ignored in "from module inport *"

	List comprehensions:

		[i for i in range(10)] -> [1,2,3,4,5,6,7,8,9]

Javascript:

	a = new SomeFunction()...   Calls function and returns its scope, as if its last
		line was "return this".  I think it reparents the scope to the construction
		function's prototype.

	'this' is interesting.  It's not the current scope.  Instead it's the obj the function is running in.  For example,
	you can do this: { name: "fred", mymethod: function() { print this.name } }
	[it's like self in python]

	So when you call a member function, the object is passed as an argument called this.

	Construction functions have properties.  One is the prototype objects which should get the methods:

	SomeFunction.prototype.mymethod = function()...

	somefunction.call(a,...     'a' becomes 'this' when somefunction is run.  This provides a way to call a constructor
	function with a different scope than the one it would normally create when new is called.
	Allows you to call base-class constructors from derived class constructors.

	function Derived(a,y,z)
             Base.call(this, z,y,z)
             this.fred = 7

	To inherit you do this:

	I think correct way is: Derived.prototype = Object.create(Base.prototype) # new object's __proto__ is set to Base.prototype

	But constructor property of Derived.prototype is now wrong, so fix it with:

	Object.defineProperty(Derived.prototype, 'constructor', { value: Derived, enumerable: flase, writable: trye });

	yuck.

	Newer versions added a class syntax with extends for inheritance.

	Settings and getters:
		It has getters and setters: getter is a function called when reading:
			print a.b    b is called, returns value
		Likewise setter:
			a.b=5

	Arrow functions:
		a => a*a
		(a, b) => a+b

		- They are lightweight, don't have their own argv or this.

	Argument initializers:
		There is a problem with running the code at function define time.  Objects can be modified,
		so subsequent calls ge different values.

			fn foo(x=[]) { return x }
			foo()(1)=1
			foo() -> now returned array is [1]

		There is no difference between explicitly passing in void or not providing the value.  In either case the initializer
		is called.  So initializers could be implemented like this:
			if a==void a=default_value_for_a
			if b==void b=default_value_for_b
			etc.

		Note that code for "default_value_for_b" is allowed to use the initialized value of a.

	NaN and Infinity are valid floating point values.

	a ** b is exponentiation

	It had array comprehensions, but removed.

	[a, b, ...rest] = [1, 2, 3, 4, 5]  => rest becomes an array with remaining items
	[a, b] = [1, 2, 3] => target can be shorter
	[a, b, c=3] = [1, 2] => there can be default values
	[a, ,c] = [1, 2, 3] => ignoring some values

	It as a "pipeline" operator for chained function calls:

		123 |> foo |> bar is the same as bar(foo(123))

	It has spread syntax:

		sum(...array)

		The array is converted into a variable length argument list.

	It had a way to create a circular list in one line...

Use ivy_ prefix for everything (simplifies inclusion) 

include is broken (needs to push input I think)

Thunks should not have their own scope?

  fn set(&a, b) { *a = b }
  set x 9   # x is void after this
  x=1
  set x 9   # now x is 9
  set mom.y 9  # y is 9...

They probably should not.. but this is a PITA..

Garbage collector:

  use an allocator for the protection structures

  can we eliminate the protection structures?  Mark newly created objects
  some other way (generation number in the object or something)



Object oriented features:

 a=[]  automatically set mom of this object to parent:
         a=[`mom=this]?
         We can't really do this.. a.print will turn up in non-objects.
         On the other hand we would like it for making objects.

 add something like this: z.a.call(b,...) so we can call with different mom.
    (a is called with mom set to b instead of z)

 Add modules, inheritance, etc..



More features?
	Exceptions.

	Continuations or co-routines (haven't decided yet: leaning towards
	co-routines, but designing for continuations).

	First-class regular expressions, as in perl.

	All UNIX system calls and library functions, as in perl.

	Widget library and X interface.  I'd like to use Ivy as a
	replacement for "gnu-plot" (and when built into JOE, as a free
	version of "mathcad").


print source code line number when we crash, not just stack trace.

make switch native for speed?

add tests for "continue"

Simplifications:
  Dump 'dynamic'.. it's intersting, but do we ever need it?

a(3)="hi" used to work for the case where a is a string.  This broke when we added val->var... val->var should be a POS for this case.
[we got rid of this feature for now]






Lack of keyword problems [this is probably ok]:

define and call is weird:

	y=fn((),{ body })()
	y={ fn () { body } }()

	it would be nice if we had:
		y=fn(){ body }()
	or
		z=fn(){ body }

  # Doesn't work because while is not a keyword..
       x=0 while x!=10 {
         x=x+1
       }

  # have to do this:
       x = 0; while ...
    or
       x = 0; while(x!=10,...)

  loop break          does not work (treat break as a keyword here?)
  loop break()        this does work


loop [break]        does work
fred: loop [break]  does not work


form 1:	with a b c			ok
form 2: with (a, b, c) print(x)		ok

form 3: with a b c [print x]
form 4: with a b c
           print x

form 5: with a b c print(x)		not possible




We could do this:
     with (a, b, c) print(x)
  but then it means we have to do this:
     [with (a,b,c); print x]

Analogy:
     var (a, b, c) x=7
     [var (a, b, c); x=7 ]




How to have a chain of lambda callbacks without brackets?

read_file "fred" fn((er, data),{
	write_file "bar" fn((er),{
		if er
	})
})



Fixed:

check that objects get deleted..  I'm confused about rmvlvl.. we set ivy->vars
to get_mom(ivy->vars).. but why no refcount transfer here.

 We track references to variables, for example if a closure goes away but a
 variable within it is still being referenced, we keep the variable..  but in
 current implementation:

  Refernece leak:
    get var
    get var
    add     reduces stack by one but doesn't reference var

  I think overhead for this is high.

  We track references in this case:
     a=5    We get value of a on left side, but as side effect take a reference on the variable a.
[above is fixed, we now use garbage collection]

  valid command typed after one with error would not work
  'break fred' was crashing inside a loop with no name

  fn((),fn((),print("inner")))()() was not working because scope was being deleted
  even though there was still a reference to it.

  we now allow:
     var (x,y) print(x+y)
     var x y [print x+y]

  'this' is now working (we had made 'this' a variable in an object: now
  it's a magic value- magic value is better: can not write to it, does not
  create circular reference).

  Added `name loop labels

  break and return deep in expressions now works

  why does this crash?: print /2
  [fixed]

  we now allow strings to cross lines

  we allow \ as last character in a string to ignore the line crossing

  we do not try to get more input if the line ends with an infix operator:
     print 1+
     2
  [fixed]

this crashes:
    fn set(&a &b) {
       *a = *b
    }
[fixed]

Dump 'with'.. it's interesting, but do we ever need it?
[dumped]

Instead of obj->next, we now use obj.mom (variable mom in obj).  So there is
now only a single link to the parent.  Also now, the parent can be changed
with an assignment.  Parent can be set on regular objects, not just scoping
levels.

line ending with ; mess up
[fixed]

Need a way to have & implied on variable arguments.
  If & is on last argument, then any extra have it?
[done- now we can implement switch]

a.b()  : run b with mom set to a?  (javascript a.b.call(a))
[done]

foreach/forindex only work on arrays- it should also work on objects
[fixed- now it works on objects]

add forin (gets index instead of value as in foreach)
[done: we added forindex]

forindex doesn't handle changes to the object while it's running.  Make a
 snapshot of the object indexes before running?
[this is ok: user can dup if he wants.  We can't crash if object is modified while
being iterated]

mixing named and numbered args is weird:
  we assign left to right.  NUmber starts at first arg.
[don't care]

Read non-existant should return void but not allocate space.
[fixed]

Space in objects is allocated even if we only read it:

	a=[1]
	print a(100000)

	a(0) has 1 and a(100000) has void.  Array is expanded to 100,000.

	This is difficult to fix since we return an l-value on read in case there might be a write.

val->var: we need this on the stack and in objects for multi-assign can we
always get just the var?  read the actual val when we need it..  I'm worried
we won't have the value when the programmer read it, but some later version
prove that this never happens...

fail or return void if we access an uninitialized location?

instead of var, we should have object + index
would remove one level of indirection..

  Obj *, Num
  Obj *, Nam
  Obj *, Str

- - - -
