
Notes from other languages:

Python:

      Classes:

        class foo(BaseClass):
           x=10
           def __init__(self, iz):  # Magic special init function
              BaseClass.__init__()
              self.x=iz
           def myfunc(self):
              print self.x

        instance = foo(10)  # create instance, __init__ is called.

      Magic methods:
          __str__    How it's printed

      Modules:

        import module
        import module as foo
        from module import name

      Iterators:
        it = iter(foo)   Gets iterator of class (calls __iter__())
        next(it)         Get next value
        for x in foo:    Nice syntax for this.
        raise StopIteration to indicate end..

      _ can be used to ignore in multiple assign x, _, z = 1, 2, 3;
      names beginning with _ are ignored in "from module inport *"

Javascript:

	a = new SomeFunctio()...   Calls function and returns its scope, as if last
		line was return this.  Also set object's prototype to function's prototype:

	Functions have prototypes...

	fn construct_fred()...
	construct_fred.prototype = { }

	Objects have prototypes.  If method can't be found in object, it checks the prototype.
	are prototypes searched or copied during construction?  Book says they are searched.

	somefunction.call(a,...     'a' becomes 'this' when somefunction is run.  This provides a way to call a constructor
	function with a different scope than the one it would normally create when new is called.
	Allows you to call base-class constructors from derived class constructors.

	There is an example where for a derived class, they assign the prototype as follows:

	derived_constructor.prototype = new base()  This seems weird to me,
	since you get the instances and prototype from the base..

	Settings and getters:
		It has getters and setters: getter is a function called when reading:
			print a.b    b is called, returns value
		Likewise setter:
			a.b=5

	Arrow functions:
		a => a*a
		(a, b) => a+b

		- They are lightweight, don't have their own argv or this.

	Argument initializers:
		There is a problem with running the code at function define time.  Objects can be modified,
		so subsequent calls ge different values.

			fn foo(x=[]) { return x }
			foo()(1)=1
			foo() -> now returned array is [1]

		There is no difference between explicitly passing in void or not providing the value.  In either case the initializer
		is called.  So initializers could be implemented like this:
			if a==void a=default_value_for_a
			if b==void b=default_value_for_b
			etc.

		Note that code for "default_value_for_b" is allowed to use the initialized value of a.

	NaN and Infinity are valid floating point values.

	a ** b is exponentiation

	It had array comprehensions, but removed.

	[a, b, ...rest] = [1, 2, 3, 4, 5]  => rest becomes an array with remaining items
	[a, b] = [1, 2, 3] => target can be shorter
	[a, b, c=3] = [1, 2] => there can be default values
	[a, ,c] = [1, 2, 3] => ignoring some values

	It as a "pipeline" operator for chained function calls:

		123 |> foo |> bar is the same as bar(foo(123))

	It has spread syntax:

		sum(...array)

		The array is converted into a variable length argument list.

	It had a way to create a circular list in one line...

Use ivy_ prefix for everything (simplifies inclusion) 

include is broken (needs to push input I think)

Thunks should not have their own scope?

  fn set(&a, b) { *a = b }
  set x 9   # x is void after this
  x=1
  set x 9   # now x is 9
  set mom.y 9  # y is 9...

They probably should not.. but this is a PITA..

Garbage collector:

  use an allocator for the protection structures

  can we eliminate the protection structures?  Mark newly created objects
  some other way (generation number in the object or something)



Object oriented features:

 a=[]  automatically set mom of this object to parent:
         a=[`mom=this]?
         We can't really do this.. a.print will turn up in non-objects.
         On the other hand we would like it for making objects.

 add something like this: z.a.call(b,...) so we can call with different mom.
    (a is called with mom set to b instead of z)

 Add modules, inheritance, etc..



More features?
	Exceptions.

	Continuations or co-routines (haven't decided yet: leaning towards
	co-routines, but designing for continuations).

	First-class regular expressions, as in perl.

	All UNIX system calls and library functions, as in perl.

	Widget library and X interface.  I'd like to use Ivy as a
	replacement for "gnu-plot" (and when built into JOE, as a free
	version of "mathcad").


print source code line number when we crash, not just stack trace.

make switch native for speed?

add tests for "continue"

Simplifications:
  Dump 'dynamic'.. it's intersting, but do we ever need it?

a(3)="hi" used to work for the case where a is a string.  This broke when we added val->var... val->var should be a POS for this case.
[we got rid of this feature for now]






Lack of keyword problems [this is probably ok]:

define and call is weird:

	y=fn((),{ body })()
	y={ fn () { body } }()

	it would be nice if we had:
		y=fn(){ body }()
	or
		z=fn(){ body }

  # Doesn't work because while is not a keyword..
       x=0 while x!=10 {
         x=x+1
       }

  # have to do this:
       x = 0; while ...
    or
       x = 0; while(x!=10,...)

  loop break          does not work (treat break as a keyword here?)
  loop break()        this does work


loop [break]        does work
fred: loop [break]  does not work


form 1:	with a b c			ok
form 2: with (a, b, c) print(x)		ok

form 3: with a b c [print x]
form 4: with a b c
           print x

form 5: with a b c print(x)		not possible




We could do this:
     with (a, b, c) print(x)
  but then it means we have to do this:
     [with (a,b,c); print x]

Analogy:
     var (a, b, c) x=7
     [var (a, b, c); x=7 ]




How to have a chain of lambda callbacks without brackets?

read_file "fred" fn((er, data),{
	write_file "bar" fn((er),{
		if er
	})
})



Fixed:

check that objects get deleted..  I'm confused about rmvlvl.. we set ivy->vars
to get_mom(ivy->vars).. but why no refcount transfer here.

 We track references to variables, for example if a closure goes away but a
 variable within it is still being referenced, we keep the variable..  but in
 current implementation:

  Refernece leak:
    get var
    get var
    add     reduces stack by one but doesn't reference var

  I think overhead for this is high.

  We track references in this case:
     a=5    We get value of a on left side, but as side effect take a reference on the variable a.
[above is fixed, we now use garbage collection]

  valid command typed after one with error would not work
  'break fred' was crashing inside a loop with no name

  fn((),fn((),print("inner")))()() was not working because scope was being deleted
  even though there was still a reference to it.

  we now allow:
     var (x,y) print(x+y)
     var x y [print x+y]

  'this' is now working (we had made 'this' a variable in an object: now
  it's a magic value- magic value is better: can not write to it, does not
  create circular reference).

  Added `name loop labels

  break and return deep in expressions now works

  why does this crash?: print /2
  [fixed]

  we now allow strings to cross lines

  we allow \ as last character in a string to ignore the line crossing

  we do not try to get more input if the line ends with an infix operator:
     print 1+
     2
  [fixed]

this crashes:
    fn set(&a &b) {
       *a = *b
    }
[fixed]

Dump 'with'.. it's interesting, but do we ever need it?
[dumped]

Instead of obj->next, we now use obj.mom (variable mom in obj).  So there is
now only a single link to the parent.  Also now, the parent can be changed
with an assignment.  Parent can be set on regular objects, not just scoping
levels.

line ending with ; mess up
[fixed]

Need a way to have & implied on variable arguments.
  If & is on last argument, then any extra have it?
[done- now we can implement switch]

a.b()  : run b with mom set to a?  (javascript a.b.call(a))
[done]

foreach/forindex only work on arrays- it should also work on objects
[fixed- now it works on objects]

add forin (gets index instead of value as in foreach)
[done: we added forindex]

forindex doesn't handle changes to the object while it's running.  Make a
 snapshot of the object indexes before running?
[this is ok: user can dup if he wants.  We can't crash if object is modified while
being iterated]

mixing named and numbered args is weird:
  we assign left to right.  NUmber starts at first arg.
[don't care]

Read non-existant should return void but not allocate space.
[fixed]

Space in objects is allocated even if we only read it:

	a=[1]
	print a(100000)

	a(0) has 1 and a(100000) has void.  Array is expanded to 100,000.

	This is difficult to fix since we return an l-value on read in case there might be a write.

val->var: we need this on the stack and in objects for multi-assign can we
always get just the var?  read the actual val when we need it..  I'm worried
we won't have the value when the programmer read it, but some later version
prove that this never happens...

fail or return void if we access an uninitialized location?

instead of var, we should have object + index
would remove one level of indirection..

  Obj *, Num
  Obj *, Nam
  Obj *, Str

- - - -
